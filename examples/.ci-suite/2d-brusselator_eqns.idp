//
// 2d-brusselator_eqns.idp
// Chris Douglas
// christopher.douglas@duke.edu
//
// macros
  macro vdotu(v, u) (v*u + v#Y*u#Y) //EOM

  macro diff(v, u) (dx(v)*dx(u) + dy(v)*dy(u)) //EOM

// Define KSP parameters
  string KSPparams = "-ksp_type preonly -pc_type lu -mat_mumps_icntl_13 1";

// Boundary conditions
  macro BoundaryConditions(u, U)
    on(BCdX, BCnX, (abs(int(sym(0))) % 2)*BCsX, (abs(int(sym(1))) % 2)*BCsY, u = U - params["A"], u#Y = U#Y - params["B"]/params["A"])
  // EOM
  macro HomBoundaryConditions(u)
    on(BCdX, BCnX, (abs(int(sym(0))) % 2)*BCsX, (abs(int(sym(1))) % 2)*BCsY, u = 0, u#Y = 0)
  // EOM

// RESIDUAL OPERATOR
  varf vR(defu(dum), defu(v))
    = int2d(Th, qforder=3)(
      (ub - params["A"])*v + (vY - v)*(ub*ubY - params["B"])*ub + params["1/L^2"]*(params["Dx"]*diff(v, ub) + params["Dy"]*diff(vY, ubY))
    )
    + BoundaryConditions(dum, ub);

// JACOBIAN OPERATOR
  varf vJ(defu(dum), defu(v))
    = int2d(Th, qforder=3)(
      iomega*vdotu(v, dum) + dum*v + (vY - v)*((ub*dumY + 2.0*dum*ubY)*ub - params["B"]*dum) + params["1/L^2"]*(params["Dx"]*diff(v, dum) + params["Dy"]*diff(vY, dumY))
    )
    + int2d(Th, qforder=3)(
      iomega*vdotu(v, um) + um*v + (vY - v)*((ub*umY + 2.0*um*ubY)*ub - params["B"]*um) + params["1/L^2"]*(params["Dx"]*diff(v, um) + params["Dy"]*diff(vY, umY))
    )
    + HomBoundaryConditions(dum);

// MASS OPERATOR
  varf vM(defu(dum), defu(v))
    = int2d(Th, qforder=3)( vdotu(v, dum) )
    + int2d(Th, qforder=3)( vdotu(v, um) )
    + HomBoundaryConditions(dum);

// MASS DERIVATIVE OPERATOR
  varf vdM(defu(dum), defu(v))
    = HomBoundaryConditions(dum);

// MASS 2ND DERIVATIVE OPERATOR
  varf vddM(defu(dum), defu(v))
    = HomBoundaryConditions(dum);

// FORCING/RESPONSE OPERATORS
  varf vMq(defu(dum), defu(v))
    = int2d(Th, qforder=3)( vdotu(v, dum) )
    + int2d(Th, qforder=3)( vdotu(v, um) );

  varf vMf(deff(fm), deff(v))
    = int2d(Th, qforder=3)( vdotu(v, fm) );

  varf vP(deff(fm), defu(v))
    = int2d(Th, qforder=3)( vdotu(v, fm) );

// HESSIAN OPERATOR
  varf vH(defu(dum), defu(v))
    = int2d(Th, qforder=3)(
      2.0*(vY - v)*(dum*(ub*umY + um*ubY) + ub*um*dumY)
    )
    + int2d(Th, qforder=3)(
      2.0*(vY - v)*(um2*(ub*umY + um*ubY) + ub*um*um2Y)
    )
    + HomBoundaryConditions(dum);

// TRESSIAN OPERATOR
  varf vT(defu(dum), defu(v))
    = int2d(Th, qforder=3)(
      2.0*(vY - v)*(um2*(dum*umY + um*dumY) + dum*um*um2Y)
    )
    + int2d(Th, qforder=3)(
      2.0*(vY - v)*(um2*(um3*umY + um*um3Y) + um3*um*um2Y)
    )
    + HomBoundaryConditions(dum);